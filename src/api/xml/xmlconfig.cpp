/*

Nullsoft WASABI Source File License

Copyright 1999-2003 Nullsoft, Inc.

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

*/
#include "precomp.h"

#include "xmlconfig.h"

#include <bfc/pair.h>
#include <bfc/ptrlist.h>
#include <parse/pathparse.h>
#include <api/xml/xmlwrite.h>
#include <api/api.h>
#include <api/xml/xmlreader.h>
#include <bfc/string/url.h>

class StringPair : public Pair<String, String> {
public:
  StringPair(const char *a, const char *b) : Pair<String, String>(a, b) {}
};

static String iniFile;

#ifndef XNFNAME // you can use wasabicfg to define a custom congif name
#define XNFNAME "config.xml"
#endif

class StringPairCompare {
public:
  static int compareItem(StringPair *p1, StringPair *p2) {
    int r = STRCMP(p1->a.getValue(), p2->a.getValue());
    if (r == 0) return CMP3(p1, p2);
    else return r;
  }
  static int compareAttrib(const char *attrib, StringPair *item) {
    return STRCMP(attrib, item->a.getValue());
  }
};

static PtrListQuickSorted<StringPair, StringPairCompare> strings;

class Reader : public XmlReaderCallbackI {
public:
  ~Reader();
  virtual void xmlReaderOnStartElementCallback(const char *xmlpath, const char *xmltag, XmlReaderParams *params);
  virtual void xmlReaderOnEndElementCallback(const char *xmlpath, const char *xmltag);
  virtual int xmlReaderDisplayErrors() { return 0; }

  void readem();

private:
  PtrList<String> sections;
};

Reader::~Reader() {
  sections.deleteAll();
}

void Reader::xmlReaderOnStartElementCallback(const char *xmlpath, const char *xmltag, XmlReaderParams *params) {
  if (!STRICMP(xmltag, "section")) {
    const char *name = params->getItemValue("name");
    if (name == NULL) return;
    sections.addItem(new String(name));
  }
  if (!STRICMP(xmltag, "entry")) {
    const char *name = params->getItemValue("name");
    const char *value = params->getItemValue("value");
    if (name == NULL || value == NULL) return;
    String n;
    for (int i = 0; i < sections.getNumItems(); i++) {
      n += *sections[i];
      n += "/";
    }
    n += name;
    StringPair *p = new StringPair(n, value);
    strings.addItem(p);
  }
}

void Reader::xmlReaderOnEndElementCallback(const char *xmlpath, const char *xmltag) {
  if (!STRICMP(xmltag, "section")) {
    String *last = sections.getLast();
    sections.removeLastItem();
    delete last;
  }
}

void Reader::readem() {
  strings.deleteAll();

  if (iniFile.isempty()) {
    iniFile = WASABI_API_APP->path_getUserSettingsPath();
    iniFile.cat(DIRCHARSTR);
    iniFile.cat(XNFNAME);
  }

  XmlReader::registerCallback("WinampXML/configuration", this);
  XmlReader::registerCallback("WinampXML/configuration/*", this);
  XmlReader::registerCallback("WasabiXML/configuration", this);
  XmlReader::registerCallback("WasabiXML/configuration/*", this);

  XmlReader::loadFile(iniFile, "", this);

  XmlReader::unregisterCallback(this);
}

StringPair *XmlConfigFile::getPair(const char *name) {
  ASSERT(!sectionname.isempty());
  StringPrintf nname("%s/%s", sectionname.getValue(), name);
  return strings.findItem(nname);
}

StringPair *XmlConfigFile::makePair(const char *name, const char *value) {
  StringPair *ret = getPair(name);
  if (ret == NULL) {
    StringPrintf nname("%s/%s", sectionname.getValue(), name);
    ret = new StringPair(nname, value);
    strings.addItem(ret);
  } else {
    ret->b.setValue(value);
  }
  return ret;
}

static int ninstances = 0;
static int inited = 0;

XmlConfigFile::XmlConfigFile(const char *section, const char *name) {
  sectionname = section;
  prettyname = name;
  ninstances++;
}

void XmlConfigFile::initialize() {
  if (!inited) {
    Reader().readem();
    inited++;
  }
}

XmlConfigFile::~XmlConfigFile() {
  ninstances--;
  if (ninstances == 0) {
    FILE *fp = fopen(iniFile, "wt");
    if (fp != NULL) {
      // write out the file
      XMLWrite xml(fp, "WasabiXML");
      xml.comment(StringPrintf("Generated by: %s (%d)", WASABI_API_APP->main_getVersionString(), WASABI_API_APP->main_getBuildNumber()));
      xml.pushCategory("configuration");

      PtrList<String> cats;

      for (int i = 0; i < strings.getNumItems(); i++) {
        StringPair *p = strings[i];
        PathParser pp(p->a);

        int climit = MIN(pp.getNumStrings()-1, cats.getNumItems());
        int j;
        for (j = 0; j < climit; j++) {
          if (STRICMP(*cats[j], pp.enumString(j))) {
            climit = j;
            break;
          }
        }

        while (cats.getNumItems() > climit) {
          String *s = cats.getLast();
          xml.popCategory();
          cats.removeLastItem();
          delete s;
        }
        for (j = climit; j < pp.getNumStrings()-1; j++) {
          String *s = cats.addItem(new String(pp.enumString(j)));
          xml.pushCategoryAttrib("section");
          String enc = *s;
          Url::encode(enc, FALSE, URLENCODE_EXCLUDE_7BIT_ABOVEEQ32);
          xml.writeCategoryAttrib("name", enc);
          xml.closeCategoryAttrib();
        }

        xml.pushCategoryAttrib("entry", TRUE);
        String enc = pp.getLastString();
        Url::encode(enc, FALSE, URLENCODE_EXCLUDE_7BIT_ABOVEEQ32);
        xml.writeCategoryAttrib("name", enc);
        enc = p->b;
        Url::encode(enc, FALSE, URLENCODE_EXCLUDE_7BIT_ABOVEEQ32);
        xml.writeCategoryAttrib("value", enc);
        xml.closeCategoryAttrib();
        xml.popCategory();
      }

      while (xml.popCategory()) ;
      cats.deleteAll();
      strings.deleteAll();
      strings.purge();
      cats.purge();
      fclose(fp);
    } // fp != NULL
    inited=0; // give back the right to parse 
  }	// ninstances==0
}

int verifyName(const char *str) {
  for (const char *p = str; *p; p++) {
    if (!ISALPHA(*p) &&
      !ISDIGIT(*p) &&
      !ISPUNCT(*p) &&
      !ISSPACE(*p) &&
      *p != '|' && *p != '_')
      return 0;
  }
  return 1;
}

void XmlConfigFile::setInt(const char *name, int val) {
  INCRITICALSECTION(cs);
  if (name == NULL) return;
  if (!verifyName(name)) {
    DebugString("illegal name given\n");
    //__asm { int 3 };
    return;
  }
  makePair(name, StringPrintf(val));
}

int XmlConfigFile::getInt(const char *name, int def_val) {
  INCRITICALSECTION(cs);
  if (name == NULL) return def_val;
  StringPair *p = getPair(name);
  if (p == NULL) return def_val;
  return ATOI(p->b.getValue());
}

void XmlConfigFile::setString(const char *name, const char *str) {
  INCRITICALSECTION(cs);
  if (name == NULL) return;
  if (!verifyName(name)) {
    DebugString("illegal name given\n");
    return;
  }
  if (str == NULL) {
    StringPair *p = getPair(name);
    if (p != NULL) {
      strings.delItem(p);
      delete p;
    }
    return;
  }
  makePair(name, str);
}

int XmlConfigFile::getString(const char *name, char *buf, int buf_len, const char *def_str) {
  INCRITICALSECTION(cs);
  if (name == NULL || buf == NULL) return -1;
  if (def_str == NULL) def_str = "";
  StringPair *p = getPair(name);
  if (p == NULL)
    STRNCPY(buf, def_str, buf_len);
  else
    STRNCPY(buf, p->b.getValueSafe(), buf_len);
  return 1;
}

int XmlConfigFile::getStringLen(const char *name) {
  INCRITICALSECTION(cs);
  if (name == NULL) return -1;
  StringPair *p = getPair(name);
  if (p == NULL) return -1;
  return STRLEN(p->b.getValueSafe());
}
