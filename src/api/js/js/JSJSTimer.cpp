// ----------------------------------------------------------------------------
// Generated by JSScriptable Factory - DO NOT EDIT
// 
// File        : ../js/JSJSTimer.cpp
// Class       : JSTimer
// class layer : Javascript Dispatcher
// ----------------------------------------------------------------------------

#include "precomp.h"
#include "JSJSTimer.h"
#include "../jstimer.h"


#pragma warning(push)
#pragma warning(disable: 4800)


JSJSTimer::JSJSTimer() {
  JSTimer *pthis = (static_cast<JSTimer *>(this));
  pthis->js_addInterface(JS_JSTimer_GUID, pthis);
  pthis->js_addClassDescriptor(&JSJSTimer::classDescriptor);
  pthis->js_addFunctionTable(JSJSTimer::functionTable);
  jsSink = new JSJSTimerEventSink(this);
  jsSink->eventSink_registerTo(pthis);
}

JSJSTimer::~JSJSTimer() {
  delete jsSink;
}

JSClass JSJSTimer::classDescriptor = {
  "JSTimer", JSCLASS_HAS_PRIVATE,
  JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
  JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,
  JSCLASS_NO_OPTIONAL_MEMBERS
};

JSFunctionSpec JSJSTimer::functionTable[] = {
  {"setDelay", JSJSTimer::fromjs_setDelay, 1, 0, 0},
  {"start", JSJSTimer::fromjs_start, 0, 0, 0},
  {"stop", JSJSTimer::fromjs_stop, 0, 0, 0},
  {0,0,0,0,0},
};

JSBool JSJSTimer::fromjs_setDelay(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
  // get instance
  JSTimer *object = static_cast<JSTimer *>(reinterpret_cast<JSScriptable *>(JS_GetPrivate(cx, obj)));
  if (!object) {
    JSScriptable::js_throwNullCallException(JSJSTimer::classDescriptor.name, JSJSTimer::functionTable[0].name);
    return JS_FALSE;
  }
  // record context
  object->js_setCurrentContext(cx);
  // int delay
  jsint p0;
  if (!JS_ValueToInt32(cx, argv[0], &p0))
    return JS_FALSE;
  argv[0] = INT_TO_JSVAL(p0);
  // call method
  ASSERT(object != NULL);
  object->setDelay(p0);
  // success
  return JS_TRUE;
}

JSBool JSJSTimer::fromjs_start(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
  // get instance
  JSTimer *object = static_cast<JSTimer *>(reinterpret_cast<JSScriptable *>(JS_GetPrivate(cx, obj)));
  if (!object) {
    JSScriptable::js_throwNullCallException(JSJSTimer::classDescriptor.name, JSJSTimer::functionTable[1].name);
    return JS_FALSE;
  }
  // record context
  object->js_setCurrentContext(cx);
  // call method
  ASSERT(object != NULL);
  object->start();
  // success
  return JS_TRUE;
}

JSBool JSJSTimer::fromjs_stop(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
  // get instance
  JSTimer *object = static_cast<JSTimer *>(reinterpret_cast<JSScriptable *>(JS_GetPrivate(cx, obj)));
  if (!object) {
    JSScriptable::js_throwNullCallException(JSJSTimer::classDescriptor.name, JSJSTimer::functionTable[2].name);
    return JS_FALSE;
  }
  // record context
  object->js_setCurrentContext(cx);
  // call method
  ASSERT(object != NULL);
  object->stop();
  // success
  return JS_TRUE;
}

// ----------------------------------------------------------------------------

void JSJSTimerEventSink::eventSink_onTimer(JSTimerEventSource *source) {
  PtrList<JSEventListener> *listeners = (static_cast<JSTimer *>(m_jsClass))->js_getEventListeners("ontimer");
  if (!listeners) return;
  jsval rv;
  foreach(*listeners)
    JSEventListener *listener = (*listeners).getfor();
    JS_CallFunctionValue(listener->m_context, listener->m_object, listener->m_function, 0, NULL, &rv);
  endfor
}


